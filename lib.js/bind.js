import {amendNode, attr, child, clearNode, isEventListenerObject} from './dom.js';
import {Pipe} from './inter.js';
import {Callable} from './misc.js';

/**
 * This modules contains a Function for creating DOM nodes (such as {@link https://developer.mozilla.org/en-US/docs/Web/API/Attr | Attr} and {@link https://developer.mozilla.org/en-US/docs/Web/API/Text | Text} nodes) that update their content automatically.
 *
 * This module directly imports the {@link module:dom}, {@link module:inter} and {@link module:misc} modules.
 *
 * @module bind
 * @requires module:dom
 * @requires module:inter
 * @requires module:misc
 */
/** */

/**
 * Objects that implement this type can be used in place of both property values and Children in calls to {@link dom:amendNode and {@link dom:clearNode}, as well as the bound element functions from the {@link module:html} and {@link module:svg} modules.
 *
 * When the value on the class is changed, the values of the properties and the child nodes will update accordingly.
 *
 * This class implements a function that can take a new value to set the binding value. This function can also be called with no argument to simply get the value of the binding.
 *
 * @param {T} [v] The value to set the binding to.
 *
 * @returns {T} The value the binding is set to.
 */
export class Binding extends Callable {
	#pipe = new Pipe();
	#value;
	#refs = 0;

	constructor(value) {
		super(function(v) {
			if (v instanceof Event && this instanceof EventTarget && this === v.currentTarget) {
				const value = self.#value;

				if (value instanceof Function) {
					return value.call(v.currentTarget, v);
				} else if (isEventListenerObject(value)) {
					return value.handleEvent(v);
				}

				return;
			}

			if (arguments.length && Object.getOwnPropertyDescriptor(Object.getPrototypeOf(self), "value")?.set) {
				self.value = v;
			}

			return self.#value;
		});

		const self = this;

		this.#value = value;
	}

	get value() {
		return this.#value;
	}

	set value(v) {
		this.#set(v);
	}

	#set(v) {
		this.#pipe.send(this.#value = v);
	}

	[attr](n, name) {
		return this.#handleRef(n, (n, v) => amendNode(n, {[name]: v}), n => !!n.parentNode, true);
	}

	get [child]() {
		return this.#handleRef(new Text(), (n, v) => n.textContent = v + "", n => !!n.parentNode, true);
	}

	#handleRef(r, update, isActive, runNow = false) {
		let ref = r;

		this.#refs++;

		const wref = new WeakRef(r),
		      fn = v => {
			const r = ref ?? wref.deref();

			if (!r) {
				this.#pipe.remove(fn);
				this.#refs--;

				return;
			}

			ref = isActive(r) ? r : null;

			update(r, v);
		      };

		this.#pipe.receive(fn);

		if (runNow) {
			update(r, this.#value);
		}

		return r;
	}

	/** This method returns a new Binding that transforms the result of the template according to the specified function. */
	transform(fn) {
		return this.#handleRef(new ReadOnlyBinding(fn(this.#value)), (n, v) => n.#set(fn(v)), n => n.#refs > 0);
	}

	/** This method runs the provided callback whenever the value changes, passing the function the current value. */
	onChange(fn) {
		const bFn = v => fn(v);

		this.#pipe.receive(bFn);

		fn(this.#value);

		return () => this.#pipe.remove(bFn);
	}

	/**
	 * The toDOM method updates the given Node with children generated by the given function. The function is called in different ways depending on the type of the bound value.
	 *
	 * For a bound Array, the function is passed each value of the Array.
	 * For a bound Set, the function is passed each value of the Set.
	 * For a bound Map, the function is passed each key/value pair.
	 * For other values, the function is simple passed the bound value.
	 *
	 * Nodes are cached based on the first param that is passed to the node generating function.
	 *
	 * If the function returns a null value it will be skipped and not cached. Duplicated array values will also not be cached.
	 *
	 * @param {ParentNode} n        The node to which children will be attached to.
	 * @param {Children}   [prefix] Child nodes to put before the output of the generating function.
	 * @param {Function}   fn       The node generating function, which takes different values depending on the bound type and returns a {@link dom:Children | Children} or null;
	 * @param {Children}   [suffix] Child nodes to put after the output of the generating function.
	 *
	 * @return {ParentNode} The passed node.
	 */
	toDOM(n, prefix, fn, suffix) {
		const aPrefix = prefix instanceof Function ? [] : prefix,
		      aSuffix = suffix ?? (fn instanceof Function ? [] : fn ?? []),
		      aFn = prefix instanceof Function ? prefix : fn instanceof Function ? fn : null;

		let cache = new Map();

		return aFn ? this.#handleRef(n, (n, v) => {
			const es = [],
			      elems = new Map();

			es.push(aPrefix);

			if (v instanceof Map) {
				for (const [k, u] of v.entries()) {
					const e = cache.get(k) ?? aFn(k, u);

					if (e) {
						elems.set(k, e);
						es.push(e);
					}
				}
			} else if (v instanceof Array) {
				for (const u of v) {
					const e = !elems.has(u) && cache.get(u) || aFn(u);

					if (e) {
						elems.set(u, e);
						es.push(e);
					}
				}
			} else if (v instanceof Set) {
				for (const u of v) {
					const e = cache.get(u) ?? aFn(u);

					if (e) {
						elems.set(u, e);
						es.push(e);
					}
				}
			} else {
				const e = cache.get(v) ?? aFn(v);

				if (e) {
					elems.set(v, e);
					es.push(e);
				}
			}

			es.push(aSuffix);

			clearNode(n, es);
			cache = elems;
		}, n => !!n.parentNode, true) : clearNode(n, [aPrefix, aSuffix]);
	}

	toString() {
		return this.#value + "";
	}

	toJSON() {
		return this.#value;
	}

	static template(strings, ...values) {
		return Binding.#multiple(values => {
			let str = "";

			for (let i = 0; i < strings.length; i++) {
				str += strings[i] + (values[i] ?? "");
			}

			return str;
	      }, values);
	}

	static #multiple(fn, values) {
		let ref = new ReadOnlyBinding(fn(values.map(v => v instanceof Binding ? v.#value : v)));

		const wref = new WeakRef(ref),
		      cancel = Pipe.any(vals => {
			const r = ref ?? wref.deref();

			if (!r) {
				for (const b of values) {
					if (b instanceof Binding) {
						b.#refs--;
					}
				}

				cancel();

				return;
			}

			ref = r.#refs ? r : null;

			r.#set(fn(vals));
		      }, ...values.map(v => v instanceof Binding ? [v.#pipe, v.#value] : v));

		for (const b of values) {
			if (b instanceof Binding) {
				b.#refs++;
			}
		}

		return ref;
	}

	static multiple(fn, ...bindings) {
		return Binding.#multiple(values => fn(...values), bindings);
	}
}

class ReadOnlyBinding extends Binding {
	get value() {
		return super.value;
	}
}

/**
 * This function can be used as a normal function, binding a single value, as a template tag function, or as a constructor for a MultiBinding.
 *
 * When used normally, this function takes a single starting value and returns a {@link Binding} class with that value set.
 *
 * @typeParam T
 * @param {T} v Value to be bound so it can be changed when assigned to an element attribute or child.
 *
 * @return {Binding<T>} Bound value.
 *
 * When used as a tag function, this function will return a readonly {@link Binding} that is bound to all Bind expressions used within the template.
 *
 * @param {TemplateStringsArray}            v    The strings portions of a temple.
 * @param {...(Binding<unknown> | unknown)} args The non-string portions of a temple, which can include Bindings to watch.
 *
 * @return {ReadonlyBinding<string>} The Binding that will update when one of the passed Bindings is updated.
 *
 * When used to create a MultiBinding, it takes, as the first argument, the function which will combine the values of the passed bindings, and the remaining arguments will be the Bindings or static value.
 *
 * @typeParam T
 * @typeParam {unknown[]} A
 * @typeParam {(Binding<unknown> | unknown>} B
 * @param {(b: ...A) => T} fn       The function to transform the values.
 * @param {...B}           bindings The bindings or static values to be watched and passed to the fn.
 *
 * @return {ReadonlyBinding<T>} The binding that is the result of the fn function, which will be updated when one of the passed Bindings changes.
 *
 * All returned types can be used as attributes or children in {@link dom:amendNode} and {@link dom:clearNode} calls.
 */
export default (v, ...bindings) => {
	if (bindings.length) {
		if (v instanceof Array) {
			return Binding.template(v, ...bindings);
		}

		if (v instanceof Function) {
			return Binding.multiple(v, ...bindings);
		}
	}

	return new Binding(v);
};
